Index: arch/amd64/amd64/conf.c
===================================================================
RCS file: /cvs/src/sys/arch/amd64/amd64/conf.c,v
retrieving revision 1.73
diff -u -p -r1.73 conf.c
--- arch/amd64/amd64/conf.c	23 Jan 2021 05:08:34 -0000	1.73
+++ arch/amd64/amd64/conf.c	20 May 2021 21:34:22 -0000
@@ -275,7 +275,7 @@ struct cdevsw	cdevsw[] =
 	cdev_acpi_init(NACPI,acpi),	/* 83: ACPI */
 	cdev_notdef(),
 	cdev_nvram_init(NNVRAM,nvram),	/* 85: NVRAM interface */
-	cdev_notdef(),			/* 86 */
+	cdev_disk_init(1,cw),		/* 86: course work */
 	cdev_drm_init(NDRM,drm),	/* 87: drm */
 	cdev_gpio_init(NGPIO,gpio),	/* 88: gpio */
 	cdev_vscsi_init(NVSCSI,vscsi),	/* 89: vscsi */
Index: arch/i386/i386/conf.c
===================================================================
RCS file: /cvs/src/sys/arch/i386/i386/conf.c,v
retrieving revision 1.171
diff -u -p -r1.171 conf.c
--- arch/i386/i386/conf.c	23 Jan 2021 05:08:35 -0000	1.171
+++ arch/i386/i386/conf.c	20 May 2021 21:34:22 -0000
@@ -275,7 +275,7 @@ struct cdevsw	cdevsw[] =
 	cdev_gpio_init(NGPIO,gpio),	/* 83: GPIO interface */
 	cdev_nvram_init(NNVRAM,nvram),	/* 84: NVRAM interface */
 	cdev_notdef(),			/* 85: ACPI (deprecated) */
-	cdev_notdef(),
+	cdev_disk_init(1,cw),		/* 86: course work */
 	cdev_notdef(),			/* 87 */
 	cdev_drm_init(NDRM,drm),	/* 88: drm */
 	cdev_amdmsr_init(NAMDMSR,amdmsr),	/* 89: amdmsr */
Index: conf/GENERIC
===================================================================
RCS file: /cvs/src/sys/conf/GENERIC,v
retrieving revision 1.275
diff -u -p -r1.275 GENERIC
--- conf/GENERIC	7 Apr 2021 00:16:00 -0000	1.275
+++ conf/GENERIC	20 May 2021 21:34:22 -0000
@@ -43,6 +43,8 @@ option		MSDOSFS		# MS-DOS file system
 option		FIFO		# FIFOs; RECOMMENDED
 #option		TMPFS		# efficient memory file system
 option		FUSE		# FUSE
+option		CWFS            # course work file system
+option		CWFS_DEBUG      # debugging of course work file system
 
 option		SOCKET_SPLICE	# Socket Splicing for TCP and UDP
 option		TCP_ECN		# Explicit Congestion Notification for TCP
@@ -89,6 +94,7 @@ pseudo-device	bpfilter	# packet filter
 pseudo-device	bridge		# network bridging support
 pseudo-device	veb		# virtual Ethernet bridge
 pseudo-device	carp		# CARP protocol support
+pseudo-device	cwnet		# MIREA course work network interface
 pseudo-device	etherip		# EtherIP (RFC 3378)
 pseudo-device	gif		# IPv[46] over IPv[46] tunnel (RFC1933)
 pseudo-device	gre		# GRE encapsulation interface
Index: conf/files
===================================================================
RCS file: /cvs/src/sys/conf/files,v
retrieving revision 1.702
diff -u -p -r1.702 files
--- conf/files	16 Apr 2021 08:17:35 -0000	1.702
+++ conf/files	20 May 2021 21:34:22 -0000
@@ -576,6 +576,8 @@ pseudo-device pppx: ifnet
 pseudo-device vxlan: ifnet, ether, ifmedia
 pseudo-device switch: ifnet, ether
 pseudo-device wg: ifnet
+pseudo-device cw: tty
+pseudo-device cwnet: ifnet, ether
 
 pseudo-device ksyms
 file	dev/ksyms.c			ksyms needs-flag
@@ -633,6 +635,8 @@ file	dev/dt/dt_prov_static.c		dt
 # XXX machine-independent SCSI files should live somewhere here, maybe
 
 # kernel sources
+file cwfs/cwfs_vfsops.c			cwfs
+file cwfs/cwfs_vnops.c			cwfs
 file ddb/db_access.c			ddb
 file ddb/db_break.c			ddb
 file ddb/db_command.c			ddb
@@ -654,6 +658,7 @@ file ddb/db_watch.c			ddb
 file ddb/db_usrreq.c			ddb
 file dev/audio.c			audio			needs-flag
 file dev/cons.c
+file dev/cw.c
 file dev/diskmap.c
 file dev/firmload.c			firmload
 file dev/ic/dp8390.c			dp8390nic
@@ -827,6 +861,7 @@ file net/rtable.c
 file net/route.c
 file net/rtsock.c
 file net/slcompress.c			ppp
+file net/if_cwnet.c
 file net/if_enc.c			enc
 file net/if_gre.c			gre			needs-count
 file net/if_trunk.c			trunk
Index: cwfs/cwfs_extern.h
===================================================================
RCS file: cwfs/cwfs_extern.h
diff -N cwfs/cwfs_extern.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ cwfs/cwfs_extern.h	20 May 2021 21:34:22 -0000
@@ -0,0 +1,23 @@
+/*	$OpenBSD$	*/
+
+/*
+ * Copyright (c) YYYY YOUR NAME HERE <user@your.dom.ain>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ * Definitions used in the kernel for cwfs file system support
+ */
+
+extern const struct vfsops cwfs_vfsops;
Index: cwfs/cwfs_var.h
===================================================================
RCS file: cwfs/cwfs_var.h
diff -N cwfs/cwfs_var.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ cwfs/cwfs_var.h	20 May 2021 21:34:22 -0000
@@ -0,0 +1,131 @@
+/*	$OpenBSD$	*/
+
+/*
+ * Copyright (c) YYYY YOUR NAME HERE <user@your.dom.ain>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ * This file contains definitions of cwfs internals.
+ * Everything listed here should not be used in FS-independent code.
+ */
+
+// #define	CWFS_DEBUG
+
+#ifdef CWFS_DEBUG
+#define d_printf(...)	printf(__VA_ARGS__)
+#else
+#define d_printf(...)	(void)0
+#endif
+
+struct cwfs_node {
+	struct	vnode *i_vnode;	/* vnode associated with this inode */
+	struct	vnode *i_devvp;	/* vnode for block I/O */
+	struct	rrwlock i_lock;
+	ino_t	i_number;
+
+	// TODO
+	uid_t	i_uid;
+	gid_t	i_gid;
+	mode_t	i_mode;
+	u_quad_t i_size;
+	dev_t	i_dev;		/* in case our FS supports devices */
+	struct	timespec i_atime;
+	struct	timespec i_mtime;
+	struct	timespec i_ctime;
+};
+
+// #define VTOI(vp) ((struct cwfs_node *)(vp)->v_data)
+// #define ITOV(ip) ((ip)->i_vnode)
+
+static inline struct cwfs_node* VTOI(struct vnode *vp) {
+	return vp->v_data;
+}
+
+static inline struct vnode* ITOV(struct cwfs_node *ip) {
+	return ip->i_vnode;
+}
+
+struct cwfs_mnt {
+	struct	mount *cwm_mountp;
+	struct	netexport cwm_export;
+
+	// When mounting to real device, otherwise could be removed
+	struct	vnode *cwm_devvp;
+	dev_t	cwm_dev;
+
+	// TODO
+};
+
+// #define VFSTOCWFS(mp)	((struct cwfs_mnt *)((mp)->mnt_data))
+
+static inline struct cwfs_mnt *VFSTOCWFS(struct mount *mp) {
+	return mp->mnt_data;
+}
+
+/*
+ * Prototypes for CWFS vnode operations
+ */
+int	cwfs_lookup(void *);
+int	cwfs_open(void *);
+int	cwfs_close(void *);
+int	cwfs_access(void *);
+int	cwfs_getattr(void *);
+int	cwfs_setattr(void *);
+int	cwfs_read(void *);
+int	cwfs_ioctl(void *);
+int	cwfs_poll(void *);
+int	cwfs_mmap(void *);
+int	cwfs_seek(void *);
+int	cwfs_readdir(void *);
+int	cwfs_readlink(void *);
+int	cwfs_abortop(void *);
+int	cwfs_inactive(void *);
+int	cwfs_reclaim(void *);
+int	cwfs_link(void *);
+int	cwfs_symlink(void *);
+int	cwfs_bmap(void *);
+int	cwfs_lock(void *);
+int	cwfs_unlock(void *);
+int	cwfs_strategy(void *);
+int	cwfs_print(void *);
+int	cwfs_islocked(void *);
+int	cwfs_pathconf(void *);
+
+extern const struct vops	cwfs_vops;
+extern const struct vops	cwfs_specvops;
+#ifdef FIFO
+extern const struct vops	cwfs_fifovops;
+#endif
+
+/*
+ * Prototypes for CWFS mount point operations
+ */
+int cwfs_mount(struct mount *, const char *, void *,
+                      struct nameidata *, struct proc *);
+int cwfs_start(struct mount *, int, struct proc *);
+int cwfs_unmount(struct mount *, int, struct proc *);
+int cwfs_root(struct mount *, struct vnode **);
+int cwfs_quotactl(struct mount *, int, uid_t, caddr_t, struct proc *);
+int cwfs_statfs(struct mount *, struct statfs *, struct proc *);
+int cwfs_sync(struct mount *, int, int, struct ucred *, struct proc *);
+int cwfs_vget(struct mount *, ino_t, struct vnode **);
+int cwfs_fhtovp(struct mount *, struct fid *, struct vnode **);
+int cwfs_vptofh(struct vnode *, struct fid *);
+int cwfs_init(struct vfsconf *);
+int cwfs_check_export(struct mount *, struct mbuf *, int *,
+                             struct ucred **);
+
+#define cwfs_sysctl ((int (*)(int *, u_int, void *, size_t *, void *, \
+                                    size_t, struct proc *))eopnotsupp)
Index: cwfs/cwfs_vfsops.c
===================================================================
RCS file: cwfs/cwfs_vfsops.c
diff -N cwfs/cwfs_vfsops.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ cwfs/cwfs_vfsops.c	20 May 2021 21:34:22 -0000
@@ -0,0 +1,476 @@
+/*	$OpenBSD$	*/
+
+/*
+ * Copyright (c) YYYY YOUR NAME HERE <user@your.dom.ain>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/namei.h>
+#include <sys/proc.h>
+#include <sys/kernel.h>
+#include <sys/vnode.h>
+#include <sys/lock.h>
+#include <sys/specdev.h>
+#include <sys/mount.h>
+#include <sys/buf.h>
+#include <sys/fcntl.h>
+#include <sys/disklabel.h>
+#include <sys/ioctl.h>
+#include <sys/cdio.h>
+#include <sys/errno.h>
+#include <sys/malloc.h>
+#include <sys/stat.h>
+
+#include <cwfs/cwfs_extern.h>
+#include <cwfs/cwfs_var.h>
+
+const struct vfsops cwfs_vfsops = {
+	.vfs_mount	= cwfs_mount,
+	.vfs_start	= cwfs_start,
+	.vfs_unmount	= cwfs_unmount,
+	.vfs_root	= cwfs_root,
+	.vfs_quotactl	= cwfs_quotactl,
+	.vfs_statfs	= cwfs_statfs,
+	.vfs_sync	= cwfs_sync,
+	.vfs_vget	= cwfs_vget,
+	.vfs_fhtovp	= cwfs_fhtovp,
+	.vfs_vptofh	= cwfs_vptofh,
+	.vfs_init	= cwfs_init,
+	.vfs_sysctl	= cwfs_sysctl,
+	.vfs_checkexp	= cwfs_check_export,
+};
+
+static int	cwfs_mountfs(register struct vnode *, struct mount *, struct proc *, struct cwfs_args *);
+
+static int	cwfs_vget_internal(struct mount *, ino_t, struct vnode **);
+
+int	cwfs_debug;
+
+/*
+ * VFS Operations
+ */
+
+/*
+ * Called once at kernel startup
+ */
+int
+cwfs_init(struct vfsconf *vfsp) {
+	// TODO: perform any initial setup here, like global variables initialization
+	return (0);
+}
+
+/*
+ * mount system call
+ */
+int
+cwfs_mount(register struct mount *mp,
+	   const char *path,		// path to directory where to mount this FS
+	   void *data,			// mount parameters (FS-specific)
+	   struct nameidata *ndp,	// describes mount source, see namei(9)
+	   struct proc *p)		// the calling userspace process
+{
+	struct cwfs_mnt *cwmp = NULL;
+	struct cwfs_args *args = data;
+	struct vnode *devvp;		// vnode of device containing our FS
+	char fspec[MNAMELEN];
+	int error;
+
+	// TODO uncomment the following for read-only file system
+	// if ((mp->mnt_flag & MNT_RDONLY) == 0)
+	//	return (EROFS);
+
+	/*
+	 * If updating, check whether changing from read-only to
+	 * read/write; if there is no device name, that's all we do.
+	 */
+	if (mp->mnt_flag & MNT_UPDATE) {
+		cwmp = VFSTOCWFS(mp);
+		if (args && args->cwa_fspec == NULL)
+			return (vfs_export(mp, &cwmp->cwm_export,
+			    &args->cwa_export_info));
+		return (0);
+	}
+
+// TODO uncomment if willing to mount on real device
+#if 0
+	/*
+	 * Not an update, or updating the name: look up the name
+	 * and verify that it refers to a sensible block device.
+	 */
+	error = copyinstr(args->cwa_fspec, fspec, sizeof(fspec), NULL);
+	if (error)
+		return (error);
+	NDINIT(ndp, LOOKUP, FOLLOW, UIO_SYSSPACE, fspec, p);
+	if ((error = namei(ndp)) != 0)
+		return (error);
+
+	devvp = ndp->ni_vp;
+
+	if (devvp->v_type != VBLK) {
+		vrele(devvp);
+		return (ENOTBLK);
+	}
+	if (major(devvp->v_rdev) >= nblkdev) {
+		vrele(devvp);
+		return (ENXIO);
+	}
+#else
+	devvp = NULL;
+#endif
+
+	if ((mp->mnt_flag & MNT_UPDATE) == 0)
+		error = cwfs_mountfs(devvp, mp, p, args);
+	// TODO if needed
+	// else {
+	// 	if (devvp != cwmp->cwm_devvp)
+	// 		error = EINVAL;	/* needs translation */
+	// 	else
+	// 		vrele(devvp);
+	// }
+
+	if (error) {
+		// TODO if needed: vrele(devvp);
+		return (error);
+	}
+
+	bzero(mp->mnt_stat.f_mntonname, MNAMELEN);
+	strlcpy(mp->mnt_stat.f_mntonname, path, MNAMELEN);
+	bzero(mp->mnt_stat.f_mntfromname, MNAMELEN);
+	strlcpy(mp->mnt_stat.f_mntfromname, fspec, MNAMELEN);
+	bzero(mp->mnt_stat.f_mntfromspec, MNAMELEN);
+	strlcpy(mp->mnt_stat.f_mntfromspec, fspec, MNAMELEN);
+	bcopy(args, &mp->mnt_stat.mount_info.cwfs_args, sizeof(*args));
+
+	cwfs_statfs(mp, &mp->mnt_stat, p);
+
+	return (0);
+}
+
+/*
+ * Common code for mount and mountroot
+ */
+static int
+cwfs_mountfs(register struct vnode *devvp, struct mount *mp, struct proc *p, struct cwfs_args *argp)
+{
+	register struct cwfs_mnt *cwmp = NULL;
+	dev_t dev = devvp ? devvp->v_rdev : 0;
+	int error = EINVAL;
+	int ronly = (mp->mnt_flag & MNT_RDONLY) != 0;
+	extern struct vnode *rootvp;	// device containing root FS
+
+	// TODO uncomment the following for read-only file system
+	// if (!ronly)
+	//	return (EROFS);
+
+	cwmp = malloc(sizeof *cwmp, M_CWFSMNT, M_WAITOK);
+	bzero(cwmp, sizeof *cwmp);
+
+	// TODO: fill cwmp, goto out on error
+	if (0)
+		goto out;
+
+	mp->mnt_data = cwmp;
+	mp->mnt_stat.f_fsid.val[0] = (long)dev;
+	mp->mnt_stat.f_fsid.val[1] = mp->mnt_vfc->vfc_typenum;
+	mp->mnt_stat.f_namemax = /* TODO */ NAME_MAX;
+	mp->mnt_flag |= MNT_LOCAL;
+	cwmp->cwm_mountp = mp;
+	cwmp->cwm_dev = dev;
+	cwmp->cwm_devvp = devvp;
+
+	devvp->v_specmountpoint = mp;
+
+	return (0);
+
+out:
+	if (devvp->v_specinfo)
+		devvp->v_specmountpoint = NULL;
+
+	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY);
+	VOP_CLOSE(devvp, ronly ? FREAD : FREAD|FWRITE, NOCRED, p);
+	VOP_UNLOCK(devvp);
+
+	if (cwmp) {
+		free(cwmp, M_CWFSMNT, sizeof(*cwmp));
+		mp->mnt_data = NULL;
+	}
+	return (error);
+}
+
+/*
+ * Make a filesystem operational; called at the end of (non-update) mount operation.
+ */
+/* ARGSUSED */
+int
+cwfs_start(struct mount *mp, int flags, struct proc *p)
+{
+	return (0);
+}
+
+/*
+ * unmount system call
+ */
+int
+cwfs_unmount(struct mount *mp, int mntflags, struct proc *p)
+{
+	register struct cwfs_mnt *cwmp;
+	int error, flags = 0;
+
+	if (mntflags & MNT_FORCE)
+		flags |= FORCECLOSE;
+	if ((error = vflush(mp, NULLVP, flags)) != 0)
+		return (error);
+
+	cwmp = VFSTOCWFS(mp);
+
+	if (cwmp->cwm_devvp) {
+		cwmp->cwm_devvp->v_specmountpoint = NULL;
+		vn_lock(cwmp->cwm_devvp, LK_EXCLUSIVE | LK_RETRY);
+		(void)VOP_CLOSE(cwmp->cwm_devvp, FREAD, NOCRED, p);
+		vput(cwmp->cwm_devvp);
+	}
+	free(cwmp, M_CWFSMNT, sizeof(*cwmp));
+	mp->mnt_data = NULL;
+	mp->mnt_flag &= ~MNT_LOCAL;
+	return (0);
+}
+
+/*
+ * Return root vnode of a filesystem
+ */
+int
+cwfs_root(struct mount *mp, struct vnode **vpp)
+{
+	// struct cwfs_mnt *cwmp = VFSTOCWFS(mp);
+	ino_t ino = /* TODO */ 1;
+
+	// TODO
+
+	return (cwfs_vget_internal(mp, ino, vpp));
+}
+
+/*
+ * Do operations associated with quotas.
+ */
+/* ARGSUSED */
+int
+cwfs_quotactl(struct mount *mp, int cmd, uid_t uid, caddr_t arg, struct proc *p)
+{
+	return (EOPNOTSUPP);
+}
+
+/*
+ * Get file system statistics.
+ */
+int
+cwfs_statfs(struct mount *mp, register struct statfs *sbp, struct proc *p)
+{
+	register struct cwfs_mnt *cwmp;
+
+	cwmp = VFSTOCWFS(mp);
+
+	sbp->f_bsize = /* TODO */ 512;
+	sbp->f_iosize = sbp->f_bsize;	/* XXX */
+	sbp->f_blocks = /* TODO */ 1;	/* total blocks */
+	sbp->f_bfree = /* TODO */ 0;	/* total free blocks */
+	sbp->f_bavail = /* TODO */ 0;	/* blocks free for non superuser */
+	sbp->f_files =  /* TODO */ 0;	/* total files */
+	sbp->f_ffree = /* TODO */ 0;	/* free file nodes */
+	sbp->f_favail = /* TODO */ 0;	/* file nodes free for non superuser */
+	copy_statfs_info(sbp, mp);
+
+	return (0);
+}
+
+/* ARGSUSED */
+int
+cwfs_sync(struct mount *mp, int waitfor, int stall, struct ucred *cred, struct proc *p)
+{
+	return (0);
+}
+
+/*
+ * File handle to vnode
+ *
+ * Have to be really careful about stale file handles:
+ * - check that the inode number is in range
+ * - call iget() to get the locked inode
+ * - check for an unallocated inode (i_mode == 0)
+ * - check that the generation number matches
+ */
+
+struct ifid {
+	ushort	ifid_len;
+	ushort	ifid_pad;
+	ino_t	ifid_ino;
+};
+
+/* ARGSUSED */
+int
+cwfs_fhtovp(register struct mount *mp, struct fid *fhp, struct vnode **vpp)
+{
+	struct ifid *ifhp = (struct ifid *)fhp;
+	struct vnode *nvp;
+	int error;
+
+	d_printf("fhtovp: ino %lld\n", (long long)ifhp->ifid_ino);
+
+	if ((error = VFS_VGET(mp, ifhp->ifid_ino, &nvp)) != 0) {
+		*vpp = NULLVP;
+		return (error);
+	}
+	*vpp = nvp;
+	return (0);
+}
+
+int
+cwfs_vget(struct mount *mp, ino_t ino, struct vnode **vpp)
+{
+	// TODO: check that ino value is in valid range, panic() otherwise
+
+	return (cwfs_vget_internal(mp, ino, vpp));
+}
+
+static int
+cwfs_vget_internal(struct mount *mp, ino_t ino, struct vnode **vpp)
+{
+	register struct cwfs_mnt *cwmp;
+	struct cwfs_node *ip;
+	struct vnode *vp, *nvp;
+	dev_t dev;
+	int error;
+
+	cwmp = VFSTOCWFS(mp);
+	dev = cwmp->cwm_dev;
+
+	/* Allocate a new vnode/cwfs_node. */
+	if ((error = getnewvnode(VT_CWFS, mp, &cwfs_vops, &vp)) != 0) {
+		*vpp = NULLVP;
+		return (error);
+	}
+	ip = malloc(sizeof(*ip), M_CWFSNODE, M_WAITOK | M_ZERO);
+	rrw_init_flags(&ip->i_lock, "cwinode", RWL_DUPOK | RWL_IS_VNODE);
+	vp->v_data = ip;
+	ip->i_vnode = vp;
+	ip->i_dev = dev;
+	ip->i_number = ino;
+	ip->i_devvp = cwmp->cwm_devvp;
+	vref(ip->i_devvp);
+
+	// TODO fill cwfs_node in 'ip'
+	nanotime(&ip->i_atime);
+	ip->i_ctime = ip->i_mtime = ip->i_atime;
+
+	vp->v_type = /* TODO */ VNON;
+
+	switch (vp->v_type) {
+	case VFIFO:
+#ifdef	FIFO
+		vp->v_op = &cwfs_fifovops;
+		break;
+#else
+		vput(vp);
+		return (EOPNOTSUPP);
+#endif	/* FIFO */
+
+	case VCHR:
+	case VBLK:
+		/*
+		 * if device, look at device number table for translation
+		 */
+		vp->v_op = &cwfs_specvops;
+		if ((nvp = checkalias(vp, ip->i_dev, mp)) != NULL) {
+			/*
+			 * Discard unneeded vnode, but save its cwfs_node.
+			 * Note that the lock is carried over in the cwfs_node
+			 */
+			nvp->v_data = vp->v_data;
+			vp->v_data = NULL;
+			vp->v_op = &spec_vops;
+			vrele(vp);
+			vgone(vp);
+			/*
+			 * Reinitialize aliased inode.
+			 */
+			vp = nvp;
+			ip->i_vnode = vp;
+		}
+		break;
+
+	case VLNK:
+	case VNON:
+	case VSOCK:
+	case VDIR:
+	case VBAD:
+		break;
+	case VREG:
+		uvm_vnp_setsize(vp, ip->i_size);
+		break;
+	}
+
+	// TODO: rules may differ
+	if (ip->i_number == 1)
+		vp->v_flag |= VROOT;
+
+	/*
+	 * XXX need generation number?
+	 */
+
+	*vpp = vp;
+	return (0);
+}
+
+/*
+ * Vnode pointer to File handle
+ */
+/* ARGSUSED */
+int
+cwfs_vptofh(struct vnode *vp, struct fid *fhp)
+{
+	register struct cwfs_node *ip = VTOI(vp);
+	register struct ifid *ifhp;
+
+	ifhp = (struct ifid *)fhp;
+	ifhp->ifid_len = sizeof(struct ifid);
+
+	ifhp->ifid_ino = ip->i_number;
+
+	d_printf("vptofh: ino %lld\n", (long long)ifhp->ifid_ino);
+
+	return (0);
+}
+
+/*
+ * Verify a remote client has export rights and return these rights via
+ * exflagsp and credanonp.
+ */
+int
+cwfs_check_export(register struct mount *mp, struct mbuf *nam, int *exflagsp, struct ucred **credanonp)
+{
+	register struct netcred *np;
+	register struct cwfs_mnt *imp = VFSTOCWFS(mp);
+
+	/*
+	 * Get the export permission structure for this <mp, client> tuple.
+	 */
+	np = vfs_export_lookup(mp, &imp->cwm_export, nam);
+	if (np == NULL)
+		return (EACCES);
+
+	*exflagsp = np->netc_exflags;
+	*credanonp = &np->netc_anon;
+	return (0);
+}
Index: cwfs/cwfs_vnops.c
===================================================================
RCS file: cwfs/cwfs_vnops.c
diff -N cwfs/cwfs_vnops.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ cwfs/cwfs_vnops.c	20 May 2021 21:34:22 -0000
@@ -0,0 +1,881 @@
+/*	$OpenBSD$	*/
+
+/*
+ * Copyright (c) YYYY YOUR NAME HERE <user@your.dom.ain>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <sys/param.h>
+#include <sys/buf.h>
+#include <sys/conf.h>
+#include <sys/dirent.h>
+#include <sys/file.h>
+#include <sys/ioccom.h>
+#include <sys/ioctl.h>
+#include <sys/kernel.h>
+#include <sys/lock.h>
+#include <sys/malloc.h>
+#include <sys/mount.h>
+#include <sys/namei.h>
+#include <sys/poll.h>
+#include <sys/pool.h>
+#include <sys/resourcevar.h>
+#include <sys/specdev.h>
+#include <sys/stat.h>
+#include <sys/systm.h>
+#include <sys/time.h>
+#include <sys/unistd.h>
+#include <sys/vnode.h>
+
+#include <miscfs/fifofs/fifo.h>
+
+#include <cwfs/cwfs_extern.h>
+#include <cwfs/cwfs_var.h>
+
+int cwfs_kqfilter(void *v);
+
+
+/*
+ * Setattr call. Only allowed for block and character special devices.
+ */
+int
+cwfs_setattr(void *v)
+{
+	struct vop_setattr_args *ap = v;
+	struct vnode *vp = ap->a_vp;
+	struct vattr *vap = ap->a_vap;
+
+	if (vap->va_flags != VNOVAL || vap->va_uid != (uid_t)VNOVAL ||
+	    vap->va_gid != (gid_t)VNOVAL || vap->va_atime.tv_nsec != VNOVAL ||
+	    vap->va_mtime.tv_nsec != VNOVAL || vap->va_mode != (mode_t)VNOVAL ||
+	    (vap->va_vaflags & VA_UTIMES_CHANGE))
+		return (EROFS);
+	if (vap->va_size != VNOVAL) {
+		switch (vp->v_type) {
+		case VDIR:
+			return (EISDIR);
+		case VLNK:
+		case VREG:
+			return (EROFS);
+		case VCHR:
+		case VBLK:
+		case VSOCK:
+		case VFIFO:
+			return (0);
+		default:
+			return (EINVAL);
+		}
+	}
+
+	return (EINVAL);
+}
+
+/*
+ * Open called.
+ *
+ * Nothing to do.
+ */
+/* ARGSUSED */
+int
+cwfs_open(void *v)
+{
+	// struct vop_open_args *ap = v;
+	return (0);
+}
+
+/*
+ * Close called
+ *
+ * Update the times on the inode on writeable file systems.
+ */
+/* ARGSUSED */
+int
+cwfs_close(void *v)
+{
+	// TODO struct vop_close_args *ap = v;
+	return (0);
+}
+
+/*
+ * Check mode permission on inode pointer. Mode is READ, WRITE or EXEC.
+ * The mode is shifted to select the owner/group/other fields. The
+ * super user is granted all permissions.
+ */
+int
+cwfs_access(void *v)
+{
+	struct vop_access_args *ap = v;
+	struct cwfs_node *ip = VTOI(ap->a_vp);
+
+	return (vaccess(ap->a_vp->v_type, ip->i_mode & ALLPERMS,
+	    ip->i_uid, ip->i_gid, ap->a_mode, ap->a_cred));
+}
+
+int
+cwfs_getattr(void *v)
+{
+	struct vop_getattr_args *ap = v;
+	struct vnode *vp = ap->a_vp;
+	register struct vattr *vap = ap->a_vap;
+	register struct cwfs_node *ip = VTOI(vp);
+
+	vap->va_fsid	= ip->i_dev;
+	vap->va_fileid	= ip->i_number;
+
+	// TODO: fill values better way
+	vap->va_mode	= /* TODO: full_mode & ALLPERMS */ 0755;
+	vap->va_nlink	= 1;
+	vap->va_uid	= 0;
+	vap->va_gid	= 0;
+	vap->va_atime	= ip->i_atime;
+	vap->va_mtime	= ip->i_mtime;
+	vap->va_ctime	= ip->i_ctime;
+	vap->va_rdev	= 0;
+
+	vap->va_size	= (u_quad_t) /* TODO */ 0;
+	if (ip->i_size == 0 && vp->v_type  == VLNK) {
+		// get length of symbolic link by reading it
+
+		struct vop_readlink_args rdlnk;
+		struct iovec aiov;
+		struct uio auio;
+		char *cp;
+
+		cp = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
+		aiov.iov_base = cp;
+		aiov.iov_len = MAXPATHLEN;
+		auio.uio_iov = &aiov;
+		auio.uio_iovcnt = 1;
+		auio.uio_offset = 0;
+		auio.uio_rw = UIO_READ;
+		auio.uio_segflg = UIO_SYSSPACE;
+		auio.uio_procp = ap->a_p;
+		auio.uio_resid = MAXPATHLEN;
+		rdlnk.a_uio = &auio;
+		rdlnk.a_vp = ap->a_vp;
+		rdlnk.a_cred = ap->a_cred;
+		if (cwfs_readlink(&rdlnk) == 0)
+			vap->va_size = MAXPATHLEN - auio.uio_resid;
+		free(cp, M_TEMP, 0);
+	}
+	vap->va_flags	= /* TODO */ 0;
+	vap->va_gen	= /* TODO */ 1;
+	vap->va_blocksize = /* TODO */ 1;
+	vap->va_bytes	= (u_quad_t) /* TODO */ 0;
+	vap->va_type	= vp->v_type;
+	return (0);
+}
+
+/*
+ * Vnode op for reading.
+ */
+int
+cwfs_read(void *v)
+{
+	struct vop_read_args *ap = v;
+	struct vnode *vp = ap->a_vp;
+	register struct uio *uio = ap->a_uio;		// I/O request & result
+	register struct cwfs_node *ip = VTOI(vp);
+	register struct cwfs_mnt *cwmp;
+	int error = 0;
+
+	if (uio->uio_resid == 0)
+		return (0);
+	if (uio->uio_offset < 0)
+		return (EINVAL);
+	nanotime(&ip->i_atime);
+	cwmp = VFSTOCWFS(ITOV(ip)->v_mount);
+
+	// TODO
+
+	return (error);
+}
+
+/* ARGSUSED */
+int
+cwfs_ioctl(void *v)
+{
+	return (ENOTTY);
+}
+
+/* ARGSUSED */
+int
+cwfs_poll(void *v)
+{
+	struct vop_poll_args *ap = v;
+
+	/*
+	 * We should really check to see if I/O is possible.
+	 */
+	return (ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
+}
+
+/*
+ * Mmap a file
+ *
+ * NB Currently unsupported.
+ */
+/* ARGSUSED */
+int
+cwfs_mmap(void *v)
+{
+	return (EINVAL);
+}
+
+/*
+ * Seek on a file
+ *
+ * Nothing to do, so just return.
+ */
+/* ARGSUSED */
+int
+cwfs_seek(void *v)
+{
+	return (0);
+}
+
+/*
+ * Vnode op for readdir
+ */
+int
+cwfs_readdir(void *v)
+{
+	struct vop_readdir_args *ap = v;
+	register struct uio *uio = ap->a_uio;
+	struct vnode *vdp = ap->a_vp;
+	struct cwfs_node *dp;
+	struct cwfs_mnt *cwmp;
+	struct buf *bp = NULL;
+	int error = 0;
+
+	dp = VTOI(vdp);
+	cwmp = VFSTOCWFS(vdp->v_mount);
+
+	// TODO
+
+	if (bp)
+		brelse (bp);
+
+	uio->uio_offset = /* TODO */ 0;
+	*ap->a_eofflag = /* TODO */ 0;
+
+	return (error);
+}
+
+/*
+ * Return target name of a symbolic link
+ */
+int
+cwfs_readlink(void *v)
+{
+	struct vop_readlink_args *ap = v;
+	struct cwfs_node	*ip;
+
+	ip  = VTOI(ap->a_vp);
+
+	// TODO
+
+	return (0);
+}
+
+int
+cwfs_link(void *v)
+{
+	struct vop_link_args *ap = v;
+
+	/* TODO the code below works for read-only FS */
+	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
+	vput(ap->a_dvp);
+	return (EROFS);
+}
+
+int
+cwfs_symlink(void *v)
+{
+	struct vop_symlink_args *ap = v;
+
+	/* TODO */
+	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
+	vput(ap->a_dvp);
+	return (EROFS);
+}
+
+/*
+ * Lock an inode.
+ */
+int
+cwfs_lock(void *v)
+{
+	struct vop_lock_args *ap = v;
+	struct vnode *vp = ap->a_vp;
+
+	return rrw_enter(&VTOI(vp)->i_lock, ap->a_flags & LK_RWFLAGS);
+}
+
+/*
+ * Unlock an inode.
+ */
+int
+cwfs_unlock(void *v)
+{
+	struct vop_unlock_args *ap = v;
+	struct vnode *vp = ap->a_vp;
+
+	rrw_exit(&VTOI(vp)->i_lock);
+	return 0;
+}
+
+/*
+ * Calculate the logical to physical mapping if not done already,
+ * then call the device strategy routine.
+ */
+int
+cwfs_strategy(void *v)
+{
+	struct vop_strategy_args *ap = v;
+	struct buf *bp = ap->a_bp;
+	struct vnode *vp = bp->b_vp;
+	struct cwfs_node *ip;
+	int error;
+	int s;
+
+	ip = VTOI(vp);
+	if (vp->v_type == VBLK || vp->v_type == VCHR)
+		panic("cwfs_strategy: spec");
+	if (bp->b_blkno == bp->b_lblkno) {
+		error = VOP_BMAP(vp, bp->b_lblkno, NULL, &bp->b_blkno, NULL);
+		if (error) {
+			bp->b_error = error;
+			bp->b_flags |= B_ERROR;
+			s = splbio();
+			biodone(bp);
+			splx(s);
+			return (error);
+		}
+		if ((long)bp->b_blkno == -1)
+			clrbuf(bp);
+	}
+	if ((long)bp->b_blkno == -1) {
+		s = splbio();
+		biodone(bp);
+		splx(s);
+		return (0);
+	}
+	vp = ip->i_devvp;
+	bp->b_dev = vp->v_rdev;
+	(vp->v_op->vop_strategy)(ap);
+	return (0);
+}
+
+/*
+ * Print out the contents of an inode.
+ */
+/*ARGSUSED*/
+int
+cwfs_print(void *v)
+{
+	printf("tag VT_CWFS, cwfs vnode\n");
+	return (0);
+}
+
+/*
+ * Check for a locked inode.
+ */
+int
+cwfs_islocked(void *v)
+{
+	struct vop_islocked_args *ap = v;
+
+	return rrw_status(&VTOI(ap->a_vp)->i_lock);
+}
+
+/*
+ * Return POSIX pathconf information applicable to cwfs filesystems.
+ */
+int
+cwfs_pathconf(void *v)
+{
+	struct vop_pathconf_args *ap = v;
+	int error = 0;
+
+	switch (ap->a_name) {
+	case _PC_LINK_MAX:
+		*ap->a_retval = /* TODO */ 1;
+		break;
+	case _PC_NAME_MAX:
+		*ap->a_retval = /* TODO */ NAME_MAX;
+		break;
+	case _PC_CHOWN_RESTRICTED:
+		*ap->a_retval = /* TODO */ 1;
+		break;
+	case _PC_NO_TRUNC:
+		*ap->a_retval = /* TODO */ 1;
+		break;
+	case _PC_TIMESTAMP_RESOLUTION:
+		*ap->a_retval = /* TODO */ 1000000000;	/* one billion nanoseconds */
+		break;
+	default:
+		error = EINVAL;
+		break;
+	}
+
+	return (error);
+}
+
+/*
+ * Bmap converts a the logical block number of a file to its physical block
+ * number on the disk. The conversion is done by using the logical block
+ * number to index into the data block (extent) for the file.
+ */
+int
+cwfs_bmap(void *v)
+{
+	struct vop_bmap_args *ap = v;
+	struct cwfs_node *ip = VTOI(ap->a_vp);
+	daddr_t lblkno = ap->a_bn;
+	int bshift;
+
+	/*
+	 * Check for underlying vnode requests and ensure that logical
+	 * to physical mapping is requested.
+	 */
+	if (ap->a_vpp != NULL)
+		*ap->a_vpp = ip->i_devvp;
+	if (ap->a_bnp == NULL)
+		return (0);
+
+	/*
+	 * Compute the requested block number
+	 */
+	bshift = /* TODO */ DEV_BSHIFT;
+	*ap->a_bnp = /* TODO */ 0;
+
+	/*
+	 * Determine maximum number of readahead blocks following the
+	 * requested block.
+	 */
+	if (ap->a_runp) {
+		int nblk;
+
+		nblk = (ip->i_size >> bshift) - (lblkno + 1);
+		if (nblk <= 0)
+			*ap->a_runp = 0;
+		else if (nblk >= (MAXBSIZE >> bshift))
+			*ap->a_runp = (MAXBSIZE >> bshift) - 1;
+		else
+			*ap->a_runp = nblk;
+	}
+
+	return (0);
+}
+
+/*
+ * Convert a component of a pathname into a pointer to a locked inode.
+ * This is a very central and rather complicated routine.
+ * If the file system is not maintained in a strict tree hierarchy,
+ * this can result in a deadlock situation (see comments in code below).
+ *
+ * The flag argument is LOOKUP, CREATE, RENAME, or DELETE depending on
+ * whether the name is to be looked up, created, renamed, or deleted.
+ * When CREATE, RENAME, or DELETE is specified, information usable in
+ * creating, renaming, or deleting a directory entry may be calculated.
+ * If flag has LOCKPARENT or'ed into it and the target of the pathname
+ * exists, lookup returns both the target and its parent directory locked.
+ * When creating or renaming and LOCKPARENT is specified, the target may
+ * not be ".".  When deleting and LOCKPARENT is specified, the target may
+ * be "."., but the caller must check to ensure it does an vrele and iput
+ * instead of two iputs.
+ *
+ * Overall outline of lookup for normal file system:
+ *
+ *	check accessibility of directory
+ *	look for name in cache, if found, then if at end of path
+ *	  and deleting or creating, drop it, else return name
+ *	search for name in directory, to found or notfound
+ * notfound:
+ *	if creating, return locked directory, leaving info on available slots
+ *	else return error
+ * found:
+ *	if at end of path and deleting, return information to allow delete
+ *	if at end of path and rewriting (RENAME and LOCKPARENT), lock target
+ *	  inode and return info to allow rewrite
+ *	if not at end, add name to cache; if at end and neither creating
+ *	  nor deleting, add name to cache
+ *
+ * NOTE: (LOOKUP | LOCKPARENT) currently returns the parent inode unlocked.
+ */
+int
+cwfs_lookup(v)
+	void *v;
+{
+	struct vop_lookup_args *ap = v;
+	register struct vnode *vdp;	/* vnode for directory being searched */
+	register struct cwfs_node *dp;	/* inode for directory being searched */
+	register struct cwfs_mnt *cwmp;	/* file system that directory is in */
+	struct vnode **vpp = ap->a_vpp;
+	struct componentname *cnp = ap->a_cnp;
+	struct ucred *cred = cnp->cn_cred;
+	int error;
+	int flags;
+
+	cnp->cn_flags &= ~PDIRUNLOCK;
+	flags = cnp->cn_flags;
+
+	*vpp = NULL;
+	vdp = ap->a_dvp;
+	dp = VTOI(vdp);
+	cwmp = VFSTOCWFS(vdp->v_mount);
+
+	if ((error = VOP_ACCESS(vdp, VEXEC, cred, cnp->cn_proc)) != 0)
+		return (error);
+
+	if ((flags & ISLASTCN) && (vdp->v_mount->mnt_flag & MNT_RDONLY) &&
+	    (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
+		return (EROFS);
+
+	/*
+	 * We now have a segment name to search for, and a directory to search.
+	 *
+	 * Before tediously performing a linear scan of the directory,
+	 * check the name cache to see if the directory/name pair
+	 * we are looking for is known already.
+	 */
+	if ((error = cache_lookup(vdp, vpp, cnp)) >= 0)
+		return (error);
+
+	// TODO
+
+	/*
+	 * Insert name into cache if appropriate.
+	 */
+	if (cnp->cn_flags & MAKEENTRY)
+		cache_enter(vdp, *vpp, cnp);
+	return (0);
+}
+
+
+/*
+ * Reclaim an inode so that it can be used for other purposes.
+ */
+int
+cwfs_reclaim(void *v)
+{
+	struct vop_reclaim_args *ap = v;
+	register struct vnode *vp = ap->a_vp;
+	register struct cwfs_node *ip = VTOI(vp);
+
+#ifdef DIAGNOSTIC
+	if (vp->v_usecount != 0)
+		vprint("cwfs_reclaim: pushing active", vp);
+#endif
+
+	// TODO
+
+	/*
+	 * Purge old data structures associated with the inode.
+	 */
+	cache_purge(vp);
+	if (ip->i_devvp) {
+		vrele(ip->i_devvp);
+		ip->i_devvp = 0;
+	}
+	free(ip, M_CWFSNODE, sizeof(*ip));
+	vp->v_data = NULL;
+	return (0);
+}
+
+/*
+ * Last reference to an inode, write the inode out and if necessary,
+ * truncate and deallocate the file.
+ */
+int
+cwfs_inactive(void *v)
+{
+	struct vop_inactive_args *ap = v;
+	struct vnode *vp = ap->a_vp;
+	int error = 0;
+
+#ifdef DIAGNOSTIC
+	if (vp->v_usecount != 0)
+		vprint("cwfs_inactive: pushing active", vp);
+#endif
+
+	VOP_UNLOCK(vp);
+	/*
+	 * If we are done with the inode, reclaim it
+	 * so that it can be reused immediately.
+	 */
+	if (/* TODO */ 1)
+		vrecycle(vp, ap->a_p);
+
+	return (error);
+}
+
+/*
+ * Global vfs data structures for cwfs
+ */
+#define	cwfs_create	eopnotsupp
+#define	cwfs_mknod	eopnotsupp
+#define	cwfs_write	eopnotsupp
+#define	cwfs_fsync	nullop
+#define	cwfs_remove	eopnotsupp
+#define	cwfs_rename	eopnotsupp
+#define	cwfs_mkdir	eopnotsupp
+#define	cwfs_rmdir	eopnotsupp
+#define	cwfs_advlock	eopnotsupp
+#define	cwfs_valloc	eopnotsupp
+#define	cwfs_vfree	eopnotsupp
+#define	cwfs_truncate	eopnotsupp
+#define	cwfs_update	eopnotsupp
+#define	cwfs_bwrite	eopnotsupp
+#define cwfs_revoke	vop_generic_revoke
+
+/* Global vfs data structures for cwfs. */
+const struct vops cwfs_vops = {
+	.vop_lookup	= cwfs_lookup,
+	.vop_create	= cwfs_create,
+	.vop_mknod	= cwfs_mknod,
+	.vop_open	= cwfs_open,
+	.vop_close	= cwfs_close,
+	.vop_access	= cwfs_access,
+	.vop_getattr	= cwfs_getattr,
+	.vop_setattr	= cwfs_setattr,
+	.vop_read	= cwfs_read,
+	.vop_write	= cwfs_write,
+	.vop_ioctl	= cwfs_ioctl,
+	.vop_poll	= cwfs_poll,
+	.vop_kqfilter	= cwfs_kqfilter,
+	.vop_revoke	= cwfs_revoke,
+	.vop_fsync	= cwfs_fsync,
+	.vop_remove	= cwfs_remove,
+	.vop_link	= cwfs_link,
+	.vop_rename	= cwfs_rename,
+	.vop_mkdir	= cwfs_mkdir,
+	.vop_rmdir	= cwfs_rmdir,
+	.vop_symlink	= cwfs_symlink,
+	.vop_readdir	= cwfs_readdir,
+	.vop_readlink	= cwfs_readlink,
+	.vop_abortop	= vop_generic_abortop,
+	.vop_inactive	= cwfs_inactive,
+	.vop_reclaim	= cwfs_reclaim,
+	.vop_lock	= cwfs_lock,
+	.vop_unlock	= cwfs_unlock,
+	.vop_bmap	= cwfs_bmap,
+	.vop_strategy	= cwfs_strategy,
+	.vop_print	= cwfs_print,
+	.vop_islocked	= cwfs_islocked,
+	.vop_pathconf	= cwfs_pathconf,
+	.vop_advlock	= cwfs_advlock,
+	.vop_bwrite	= vop_generic_bwrite
+};
+
+/* Special device vnode ops */
+const struct vops cwfs_specvops = {
+	.vop_access	= cwfs_access,
+	.vop_getattr	= cwfs_getattr,
+	.vop_setattr	= cwfs_setattr,
+	.vop_inactive	= cwfs_inactive,
+	.vop_reclaim	= cwfs_reclaim,
+	.vop_lock	= cwfs_lock,
+	.vop_unlock	= cwfs_unlock,
+	.vop_print	= cwfs_print,
+	.vop_islocked	= cwfs_islocked,
+
+	/* XXX: Keep in sync with spec_vops. */
+	.vop_lookup	= vop_generic_lookup,
+	.vop_create	= spec_badop,
+	.vop_mknod	= spec_badop,
+	.vop_open	= spec_open,
+	.vop_close	= spec_close,
+	.vop_read	= spec_read,
+	.vop_write	= spec_write,
+	.vop_ioctl	= spec_ioctl,
+	.vop_poll	= spec_poll,
+	.vop_kqfilter	= spec_kqfilter,
+	.vop_revoke	= vop_generic_revoke,
+	.vop_fsync	= spec_fsync,
+	.vop_remove	= spec_badop,
+	.vop_link	= spec_badop,
+	.vop_rename	= spec_badop,
+	.vop_mkdir	= spec_badop,
+	.vop_rmdir	= spec_badop,
+	.vop_symlink	= spec_badop,
+	.vop_readdir	= spec_badop,
+	.vop_readlink	= spec_badop,
+	.vop_abortop	= spec_badop,
+	.vop_bmap	= vop_generic_bmap,
+	.vop_strategy	= spec_strategy,
+	.vop_pathconf	= spec_pathconf,
+	.vop_advlock	= spec_advlock,
+	.vop_bwrite	= vop_generic_bwrite,
+};
+
+#ifdef FIFO
+const struct vops cwfs_fifovops = {
+	.vop_access	= cwfs_access,
+	.vop_getattr	= cwfs_getattr,
+	.vop_setattr	= cwfs_setattr,
+	.vop_inactive	= cwfs_inactive,
+	.vop_reclaim	= cwfs_reclaim,
+	.vop_lock	= cwfs_lock,
+	.vop_unlock	= cwfs_unlock,
+	.vop_print	= cwfs_print,
+	.vop_islocked	= cwfs_islocked,
+	.vop_bwrite	= vop_generic_bwrite,
+
+	/* XXX: Keep in sync with fifo_vops. */
+	.vop_lookup	= vop_generic_lookup,
+	.vop_create	= fifo_badop,
+	.vop_mknod	= fifo_badop,
+	.vop_open	= fifo_open,
+	.vop_close	= fifo_close,
+	.vop_read	= fifo_read,
+	.vop_write	= fifo_write,
+	.vop_ioctl	= fifo_ioctl,
+	.vop_poll	= fifo_poll,
+	.vop_kqfilter	= fifo_kqfilter,
+	.vop_revoke	= vop_generic_revoke,
+	.vop_fsync	= nullop,
+	.vop_remove	= fifo_badop,
+	.vop_link	= fifo_badop,
+	.vop_rename	= fifo_badop,
+	.vop_mkdir	= fifo_badop,
+	.vop_rmdir	= fifo_badop,
+	.vop_symlink	= fifo_badop,
+	.vop_readdir	= fifo_badop,
+	.vop_readlink	= fifo_badop,
+	.vop_abortop	= fifo_badop,
+	.vop_bmap	= vop_generic_bmap,
+	.vop_strategy	= fifo_badop,
+	.vop_pathconf	= fifo_pathconf,
+	.vop_advlock	= fifo_advlock,
+};
+#endif /* FIFO */
+
+void filt_cwfsdetach(struct knote *kn);
+int filt_cwfsread(struct knote *kn, long hint);
+int filt_cwfswrite(struct knote *kn, long hint);
+int filt_cwfsvnode(struct knote *kn, long hint);
+
+const struct filterops cwfsread_filtops = {
+	.f_flags	= FILTEROP_ISFD,
+	.f_attach	= NULL,
+	.f_detach	= filt_cwfsdetach,
+	.f_event	= filt_cwfsread,
+};
+
+const struct filterops cwfswrite_filtops = {
+	.f_flags	= FILTEROP_ISFD,
+	.f_attach	= NULL,
+	.f_detach	= filt_cwfsdetach,
+	.f_event	= filt_cwfswrite,
+};
+
+const struct filterops cwfsvnode_filtops = {
+	.f_flags	= FILTEROP_ISFD,
+	.f_attach	= NULL,
+	.f_detach	= filt_cwfsdetach,
+	.f_event	= filt_cwfsvnode,
+};
+
+int
+cwfs_kqfilter(void *v)
+{
+	struct vop_kqfilter_args *ap = v;
+	struct vnode *vp = ap->a_vp;
+	struct knote *kn = ap->a_kn;
+
+	switch (kn->kn_filter) {
+	case EVFILT_READ:
+		kn->kn_fop = &cwfsread_filtops;
+		break;
+	case EVFILT_WRITE:
+		kn->kn_fop = &cwfswrite_filtops;
+		break;
+	case EVFILT_VNODE:
+		kn->kn_fop = &cwfsvnode_filtops;
+		break;
+	default:
+		return (EINVAL);
+	}
+
+	kn->kn_hook = (caddr_t)vp;
+
+	klist_insert(&vp->v_selectinfo.si_note, kn);
+
+	return (0);
+}
+
+void
+filt_cwfsdetach(struct knote *kn)
+{
+	struct vnode *vp = (struct vnode *)kn->kn_hook;
+
+	klist_remove(&vp->v_selectinfo.si_note, kn);
+}
+
+int
+filt_cwfsread(struct knote *kn, long hint)
+{
+	struct vnode *vp = (struct vnode *)kn->kn_hook;
+	struct cwfs_node *node = VTOI(vp);
+
+	/*
+	 * filesystem is gone, so set the EOF flag and schedule 
+	 * the knote for deletion.
+	 */
+	if (hint == NOTE_REVOKE) {
+		kn->kn_flags |= (EV_EOF | EV_ONESHOT);
+		return (1);
+	}
+
+	kn->kn_data = node->i_size - foffset(kn->kn_fp);
+	if (kn->kn_data == 0 && kn->kn_sfflags & NOTE_EOF) {
+		kn->kn_fflags |= NOTE_EOF;
+		return (1);
+	}
+
+	if (kn->kn_flags & __EV_POLL)
+		return (1);
+
+	return (kn->kn_data != 0);
+}
+
+int
+filt_cwfswrite(struct knote *kn, long hint)
+{
+	/*
+	 * filesystem is gone, so set the EOF flag and schedule 
+	 * the knote for deletion.
+	 */
+	if (hint == NOTE_REVOKE) {
+		kn->kn_flags |= (EV_EOF | EV_ONESHOT);
+		return (1);
+	}
+
+	kn->kn_data = 0;
+	return (1);
+}
+
+int
+filt_cwfsvnode(struct knote *kn, long hint)
+{
+	if (kn->kn_sfflags & hint)
+		kn->kn_fflags |= hint;
+	if (hint == NOTE_REVOKE) {
+		kn->kn_flags |= EV_EOF;
+		return (1);
+	}
+	return (kn->kn_fflags != 0);
+}
Index: dev/cw.c
===================================================================
RCS file: dev/cw.c
diff -N dev/cw.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ dev/cw.c	20 May 2021 21:34:22 -0000
@@ -0,0 +1,314 @@
+/*	$OpenBSD$	*/
+
+/*
+ * Copyright (c) 2017 YOUR NAME <email@example.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/device.h>
+#include <sys/errno.h>
+#include <sys/conf.h>
+#include <sys/lock.h>
+#include <sys/malloc.h>
+#include <sys/namei.h>
+#include <sys/proc.h>
+#include <sys/vnode.h>
+#include <sys/pledge.h>
+
+#include <sys/mount.h>
+#include <sys/syscallargs.h>
+#include <sys/filedesc.h>
+#include <sys/protosw.h>
+#include <sys/socket.h>
+#include <sys/socketvar.h>
+#include <sys/signalvar.h>
+#include <sys/file.h>
+#include <sys/ioctl.h>
+#include <sys/mbuf.h>
+#include <sys/fcntl.h>
+
+#include <sys/domain.h>
+#include <netinet/in.h>
+#include <net/route.h>
+
+#define BUFFERSIZE 255
+
+struct s_echo {
+	char msg[BUFFERSIZE + 1];
+	int len;
+};
+
+static struct s_echo echomsg;
+static int socketfd;
+//static struct sockaddr serv_addr;
+
+uint16_t mydnsjackport;
+
+static int
+mysockargs(struct mbuf **mp, const void *buf, size_t buflen, int type)
+{
+	struct sockaddr *sa;
+	struct mbuf *m;
+	//int error;
+
+	/*
+	* We can't allow socket names > UCHAR_MAX in length, since that
+	* will overflow sa_len. Also, control data more than MCLBYTES in
+	* length is just too much.
+	*/
+	if (buflen > (type == MT_SONAME ? UCHAR_MAX : MCLBYTES))
+		return (EINVAL);
+
+	/* Allocate an mbuf to hold the arguments. */
+	m = m_get(M_WAIT, type);
+	if (buflen > MLEN) {
+		MCLGET(m, M_WAITOK);
+		if ((m->m_flags & M_EXT) == 0) {
+			m_free(m);
+			return ENOBUFS;
+		}
+	}
+	m->m_len = buflen;
+	/*error = copyin(buf, mtod(m, caddr_t), buflen);
+	if (error) {
+		(void)m_free(m);
+		return (error);
+	}*/
+	*mp = m;
+	if (type == MT_SONAME) {
+		sa = mtod(m, struct sockaddr *);
+		sa->sa_len = buflen;
+	}
+	return (0);
+}
+
+int
+cwopen(dev_t dev, int flag, int fmt, struct proc *p)
+{
+	struct sys_socket_args uap_socket = { .domain = {AF_INET}, .type = {SOCK_STREAM}, .protocol = {0} };
+	struct filedesc *fdp = p->p_fd;
+	struct socket *so;
+	struct file *fp;
+	int type = SCARG(&uap_socket, type);
+	int domain = SCARG(&uap_socket, domain);
+	int fd, error, ss = 0;
+	
+	if ((type & SOCK_DNS) && !(domain == AF_INET || domain == AF_INET6))
+		return (EINVAL);
+
+	if (ISSET(type, SOCK_DNS))
+		ss |= SS_DNS;
+
+	//error = pledge_socket(p, domain, ss);
+	//if (error)
+	//{
+	//	printf("Error pledge %d\n", error);
+	//	return (error);
+	//}
+
+	//fdplock(fdp);
+	error = falloc(p, &fp, &fd);
+	//fdpunlock(fdp);
+	if (error != 0)
+		goto out;
+
+	fp->f_flag = FREAD | FWRITE | (type & SOCK_NONBLOCK ? FNONBLOCK : 0);
+	fp->f_type = DTYPE_SOCKET;
+	fp->f_ops = &socketops;
+	error = socreate(SCARG(&uap_socket, domain), &so,
+	    type & ~(SOCK_CLOEXEC | SOCK_NONBLOCK | SOCK_DNS), SCARG(&uap_socket, protocol));
+	if (error) {
+		//fdplock(fdp);
+		fdremove(fdp, fd);
+		closef(fp, p);
+		//fdpunlock(fdp);
+		return (error);
+	}
+
+	fp->f_data = so;
+	if (type & SOCK_NONBLOCK)
+		(*fp->f_ops->fo_ioctl)(fp, FIONBIO, (caddr_t)&type, p);
+	so->so_state |= ss;
+	fdinsert(fdp, fd, fdp->fd_ofileflags[fd], fp);
+	socketfd = fd;
+	fdpunlock(fdp);
+	FRELE(fp, p);
+
+	// ##### CONNECT #####
+
+	/*serv_addr.sa_family = AF_INET;
+	memset(serv_addr.sa_data, 0, 14);
+	serv_addr.sa_data[0] = 127;
+	serv_addr.sa_data[1] = 0;
+	serv_addr.sa_data[2] = 0;
+	serv_addr.sa_data[3] = 1;*/
+
+	printf("%d\n", __LINE__);
+	//const struct sockaddr* serv_addr_p = &serv_addr;
+
+	struct sockaddr_in sa;
+	sa.sin_family = AF_INET;
+	sa.sin_port = htons(22);
+	sa.sin_addr.s_addr = htonl(0x7F000001);
+
+	struct sys_connect_args uap_connect = { .s = { socketfd },.name = { .be = { .datum = (const struct sockaddr *)&sa } },.namelen = { sizeof(sa) } };
+
+	//struct file *fp;
+	//struct socket *so;
+	struct mbuf *nam = NULL;
+	int s, interrupted = 0;
+
+	printf("%d\n", __LINE__);
+	if ((error = getsock(p, SCARG(&uap_connect, s), &fp)) != 0)
+		return (error);
+	so = fp->f_data;
+	if (so->so_state & SS_ISCONNECTING) {
+		FRELE(fp, p);
+		return (EALREADY);
+	}
+	printf("%d\n", __LINE__);
+	error = mysockargs(&nam, SCARG(&uap_connect, name), SCARG(&uap_connect, namelen),
+		MT_SONAME);
+	printf("%d\n", __LINE__);
+	if (error)
+		goto bad;
+	printf("%d\n", __LINE__);
+
+	error = soconnect(so, nam);
+	if (error)
+		goto bad;
+	printf("%d\n", __LINE__);
+	if ((fp->f_flag & FNONBLOCK) && (so->so_state & SS_ISCONNECTING)) {
+		FRELE(fp, p);
+		m_freem(nam);
+		return (EINPROGRESS);
+	}
+	printf("%d\n", __LINE__);
+	s = solock(so);
+	printf("%d\n", __LINE__);
+	while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) {
+		error = sosleep_nsec(so, &so->so_timeo, PSOCK | PCATCH,
+			"netcon2", INFSLP);
+		printf("3\n");
+		if (error) {
+			if (error == EINTR || error == ERESTART)
+				interrupted = 1;
+			break;
+		}
+	}
+	printf("%d\n", __LINE__);
+	if (error == 0) {
+		error = so->so_error;
+		so->so_error = 0;
+	}
+	printf("%d\n", __LINE__);
+	sounlock(so, s);
+	printf("%d\n", __LINE__);
+
+	printf("Opened device \"cw\" successfully.\n");
+	
+	return 0;
+out:
+	return (error);
+bad:
+	if (!interrupted)
+		so->so_state &= ~SS_ISCONNECTING;
+	FRELE(fp, p);
+	m_freem(nam);
+	if (error == ERESTART)
+		error = EINTR;
+
+	fdremove(fdp, fd);
+
+	return (error);
+}
+
+int
+cwclose(dev_t dev, int flag, int fmt, struct proc *p)
+{
+	printf("Closing device \"cw\".\n");
+	
+	return 0;
+}
+
+int
+cwioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
+{
+	int error = 0;
+
+	switch (cmd) {
+	// TODO ...
+	default:
+		error = ENOTTY;
+	}
+
+	return error;
+}
+
+int
+cwread(dev_t dev, struct uio *uio, int flag)
+{
+	printf("Read %s\n", echomsg.msg);
+	
+	size_t amt;
+	int error;
+
+	/*
+	 * How big is this read operation?  Either as big as the user wants,
+	 * or as big as the remaining data.  Note that the 'len' does not
+	 * include the trailing null character.
+	 */
+	amt = MIN(uio->uio_resid, uio->uio_offset >= echomsg.len + 1 ? 0 :
+	    echomsg.len + 1 - uio->uio_offset);
+
+	if ((error = uiomove(echomsg.msg, amt, uio)) != 0)
+		printf("uiomove failed!\n");
+
+	return (error);
+}
+
+int
+cwwrite(dev_t dev, struct uio *uio, int flag)
+{
+	printf("Write %s\n", echomsg.msg);
+	
+	size_t amt;
+	int error;
+
+	/*
+	 * We either write from the beginning or are appending -- do
+	 * not allow random access.
+	 */
+	if (uio->uio_offset != 0 && (uio->uio_offset != echomsg.len))
+		return (EINVAL);
+
+	/* This is a new message, reset length */
+	if (uio->uio_offset == 0)
+		echomsg.len = 0;
+
+	/* Copy the string in from user memory to kernel memory */
+	amt = MIN(uio->uio_resid, (BUFFERSIZE - echomsg.len));
+
+	error = uiomove(echomsg.msg + uio->uio_offset, amt, uio);
+
+	/* Now we need to null terminate and record the length */
+	echomsg.len = uio->uio_offset;
+	echomsg.msg[echomsg.len] = 0;
+
+	if (error != 0)
+		printf("Write failed: bad address!\n");
+	return (error);
+}
Index: kern/Makefile
===================================================================
RCS file: /cvs/src/sys/kern/Makefile,v
retrieving revision 1.49
diff -u -p -r1.49 Makefile
--- kern/Makefile	11 May 2019 07:18:16 -0000	1.49
+++ kern/Makefile	20 May 2021 21:34:23 -0000
@@ -29,6 +29,7 @@ SYSDIR=/sys
 
 # Directories in which to place tags links (other than machine-dependent)
 DGEN=	conf \
+	cwfs \
 	ddb \
 	dev dev/eisa dev/ic dev/isa dev/pci dev/pcmcia dev/cardbus \
 	dev/sun dev/tc \
Index: kern/vfs_init.c
===================================================================
RCS file: /cvs/src/sys/kern/vfs_init.c,v
retrieving revision 1.43
diff -u -p -r1.43 vfs_init.c
--- kern/vfs_init.c	26 Dec 2019 13:30:54 -0000	1.43
+++ kern/vfs_init.c	20 May 2021 21:34:23 -0000
@@ -100,6 +100,11 @@ static struct vfsconf vfsconflist[] = {
 	{ &tmpfs_vfsops, MOUNT_TMPFS, 19, 0, MNT_LOCAL,
 	    sizeof(struct tmpfs_args) },
 #endif
+
+#ifdef CWFS
+	{ &cwfs_vfsops, MOUNT_CWFS, 20, 0, MNT_LOCAL,
+	    sizeof(struct cwfs_args) },
+#endif
 };
 
 
Index: net/if_cwnet.c
===================================================================
RCS file: net/if_cwnet.c
diff -N net/if_cwnet.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ net/if_cwnet.c	20 May 2021 21:34:23 -0000
@@ -0,0 +1,315 @@
+/* $OpenBSD$ */
+
+/*
+ * Copyright (c) 2009 Theo de Raadt
+ * Copyright (c) 2017 YOUR NAME <email@example.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/mbuf.h>
+#include <sys/socket.h>
+#include <sys/sockio.h>
+#include <sys/ioctl.h>
+
+#include <net/if.h>
+#include <net/if_media.h>
+#include <net/if_dl.h>
+
+#include <netinet/in.h>
+#include <netinet/if_ether.h>
+
+#include "bpfilter.h"
+#if NBPFILTER > 0
+#include <net/bpf.h>
+#endif
+
+#include <sys/types.h>
+#include <sys/timeout.h>
+#include <sys/task.h>
+
+#ifndef PGEN_TASKNAME
+#define PGEN_TASKNAME "pgen"
+#endif
+
+void	cwnetattach(int);
+int	cwnetioctl(struct ifnet *, u_long, caddr_t);
+void	cwnetqstart(struct ifqueue *);
+int	cwnet_clone_create(struct if_clone *, int);
+int	cwnet_clone_destroy(struct ifnet *);
+int	cwnet_media_change(struct ifnet *);
+void	cwnet_media_status(struct ifnet *, struct ifmediareq *);
+
+
+/*
+ *    
+ * 
+ */
+
+struct cwnet_softc {
+	struct arpcom		sc_ac;
+	struct ifmedia		sc_media;
+	struct task		sc_t;
+	struct timeout		sc_to;
+	//struct taskq		sc_tq;
+};
+
+/*################################################################
+ *
+ *   
+ *
+ *################################################################*/
+
+
+static void pgen_start(struct cwnet_softc *sc);
+static void pgen_gen_packs(void *arg);
+static void pgen_gen_pack(void *arg);
+static void pgen_set(struct cwnet_softc	*sc);
+static void pgen_destroy(struct cwnet_softc *sc);
+
+static char sample[] = { 
+		//destination MAC, to be overriden
+		0xFF,	0xFF,	0xFF,	0xFF,	0xFF, 	0xFF,
+		//source MAC
+		0xFC,	0xFA,	0xFB,	0xFF,	0xFF, 	0xFF,
+		//length 
+		0x00,	0x34,   
+		//source IPv4
+		0x7F, 	0x00, 	0x00, 	0x01,  
+		//destination IPv4
+		0x7F, 	0x00, 	0x00, 	0x01, 
+		//zeros|protocol|udp length
+		0x00, 	0x11, 	0x00, 	0x28, 
+		// source port |destination port
+		0x00,	0x01,	0x00,	0x02,
+		//length	|   checksum
+		0x00,	0x20,   0x00,	0x00,
+		//data
+		0x00,	0x01,	0x02,	0x03, 	
+		0x04,	0x05,	0x06,	0x07,
+		0x08,	0x09,	0x0A,	0x0B,
+		0x0C,	0x1D,	0x1E,	0x1F,
+		0x10,	0x11,	0x12, 	0x13,
+		0x14,	0x15,	0x16,	0x17,	
+		0x18,	0x19,	0x1A,	0x1B,
+		0x1C,	0x1D,	0x1E,	0x1F,
+		//checksum
+		0x00,	0x00,	0x00,	0x00
+};
+
+/*
+ *    
+ */
+static void
+pgen_start(struct cwnet_softc *sc)
+{
+	timeout_add_sec(&sc->sc_to, 1);
+}
+
+/*
+ *        
+ */
+static void
+pgen_gen_packs(void *arg)
+{
+	struct cwnet_softc *sc = arg;
+
+	task_add(systq, &sc->sc_t);
+}
+
+/*
+ *    
+ */
+static void
+pgen_gen_pack(void *arg)
+{
+	struct cwnet_softc *sc = arg;
+	struct ifnet *ifp = &sc->sc_ac.ac_if;
+	struct mbuf *m;
+	struct ether_header *eh;
+	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
+
+	// printf("gen\n");
+
+	m = MCLGETI(NULL, M_WAITOK, ifp, sizeof(sample));
+	m->m_len = m->m_pkthdr.len = sizeof(sample);
+	eh = mtod(m, struct ether_header *);
+	memcpy(eh, sample, sizeof(sample));
+	memcpy(eh->ether_dhost, LLADDR(ifp->if_sadl), 6);
+
+	ml_enqueue(&ml, m);
+	if_input(ifp, &ml);
+	pgen_start(sc);
+}
+
+/*
+ *	   
+ */
+static void
+pgen_set(struct cwnet_softc *sc)
+{
+ 	task_set(&sc->sc_t, pgen_gen_pack, sc);
+	timeout_set(&sc->sc_to, pgen_gen_packs, sc);
+}
+
+/*
+ *  
+ */
+static void
+pgen_destroy(struct cwnet_softc	*sc)
+{
+	task_del(systq, &sc->sc_t);
+	timeout_del(&sc->sc_to);
+}
+
+/*################################################################################################
+ *
+ *
+ *
+ *#################################################################################################*/
+
+
+
+struct if_clone	cwnet_cloner =
+    IF_CLONE_INITIALIZER("cwnet", cwnet_clone_create, cwnet_clone_destroy);
+
+
+int
+cwnet_media_change(struct ifnet *ifp)
+{
+	return (0);
+}
+
+void
+cwnet_media_status(struct ifnet *ifp, struct ifmediareq *imr)
+{
+	imr->ifm_active = IFM_ETHER | IFM_AUTO;
+	imr->ifm_status = IFM_AVALID | IFM_ACTIVE;
+}
+
+void
+cwnetattach(int ncwnet)
+{
+	if_clone_attach(&cwnet_cloner);
+}
+
+int
+cwnet_clone_create(struct if_clone *ifc, int unit)
+{
+	struct ifnet		*ifp;
+	struct cwnet_softc	*sc;
+
+	sc = malloc(sizeof(*sc), M_DEVBUF, M_WAITOK|M_ZERO);
+	ifp = &sc->sc_ac.ac_if;
+	snprintf(ifp->if_xname, sizeof ifp->if_xname, "cwnet%d", unit);
+	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
+	ifp->if_xflags = IFXF_MPSAFE;
+	ether_fakeaddr(ifp);
+
+	ifp->if_softc = sc;
+	ifp->if_ioctl = cwnetioctl;
+	ifp->if_qstart = cwnetqstart;
+
+	ifp->if_hardmtu = ETHER_MAX_HARDMTU_LEN;
+	ifp->if_capabilities = IFCAP_VLAN_MTU;
+
+	ifmedia_init(&sc->sc_media, 0, cwnet_media_change,
+	    cwnet_media_status);
+	ifmedia_add(&sc->sc_media, IFM_ETHER | IFM_AUTO, 0, NULL);
+	ifmedia_set(&sc->sc_media, IFM_ETHER | IFM_AUTO);
+
+	pgen_set(sc);
+	if_attach(ifp);
+	ether_ifattach(ifp);
+	return (0);
+}
+
+int
+cwnet_clone_destroy(struct ifnet *ifp)
+{
+	struct cwnet_softc	*sc = ifp->if_softc;
+
+	pgen_destroy(sc);
+	ifmedia_delete_instance(&sc->sc_media, IFM_INST_ANY);
+	ether_ifdetach(ifp);
+	if_detach(ifp);
+	free(sc, M_DEVBUF, sizeof(*sc));
+	return (0);
+}
+
+/*
+ * The bridge has magically already done all the work for us,
+ * and we only need to discard the packets.
+ */
+void
+cwnetqstart(struct ifqueue *ifq)
+{
+	struct mbuf		*m;
+	struct ifnet		*ifp;
+	struct cwnet_softc	*sc;
+
+	ifp = ifq->ifq_if;
+	sc = ifp->if_softc;
+	pgen_start(sc);
+	while ((m = ifq_dequeue(ifq)) != NULL) {
+#if NBPFILTER > 0
+		if (ifp->if_bpf)
+			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
+#endif /* NBPFILTER > 0 */
+
+		m_freem(m);
+	}
+}
+
+int
+cwnetioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
+{
+	struct cwnet_softc	*sc = (struct cwnet_softc *)ifp->if_softc;
+	struct ifreq		*ifr = (struct ifreq *)data;
+	int			 error = 0, link_state;
+
+	switch (cmd) {
+	case SIOCSIFADDR:
+		ifp->if_flags |= IFF_UP;
+		/* FALLTHROUGH */
+
+	case SIOCSIFFLAGS:
+		if (ifp->if_flags & IFF_UP) {
+			ifp->if_flags |= IFF_RUNNING;
+			link_state = LINK_STATE_UP;
+		} else {
+			ifp->if_flags &= ~IFF_RUNNING;
+			link_state = LINK_STATE_DOWN;
+		}
+		if (ifp->if_link_state != link_state) {
+			ifp->if_link_state = link_state;
+			if_link_state_change(ifp);
+		}
+		break;
+
+	case SIOCADDMULTI:
+	case SIOCDELMULTI:
+		break;
+
+	case SIOCGIFMEDIA:
+	case SIOCSIFMEDIA:
+		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
+		break;
+
+	default:
+		error = ether_ioctl(ifp, &sc->sc_ac, cmd, data);
+	}
+	return (error);
+}
Index: sys/conf.h
===================================================================
RCS file: /cvs/src/sys/sys/conf.h,v
retrieving revision 1.156
diff -u -p -r1.156 conf.h
--- sys/conf.h	23 Jan 2021 05:08:36 -0000	1.156
+++ sys/conf.h	20 May 2021 21:34:23 -0000
@@ -600,6 +600,7 @@ cdev_decl(uk);
 cdev_decl(dt);
 
 cdev_decl(diskmap);
+cdev_decl(cw);
 
 cdev_decl(bpf);
 
Index: sys/malloc.h
===================================================================
RCS file: /cvs/src/sys/sys/malloc.h,v
retrieving revision 1.121
diff -u -p -r1.121 malloc.h
--- sys/malloc.h	9 Mar 2021 15:08:23 -0000	1.121
+++ sys/malloc.h	20 May 2021 21:34:23 -0000
@@ -121,7 +121,9 @@
 #define	M_EXEC		63	/* argument lists & other mem used by exec */
 #define	M_MISCFSMNT	64	/* miscfs mount structures */
 #define	M_FUSEFS	65	/* fusefs mount structures */
-/* 66-73 - free */
+#define	M_CWFSMNT	66	/* cwfs mount structures */
+#define	M_CWFSNODE	67	/* cwfs vnode private part */
+/* 68-73 - free */
 #define	M_PFKEY		74	/* pfkey data */
 #define	M_TDB		75	/* Transforms database */
 #define	M_XDATA		76	/* IPsec data */
@@ -250,8 +252,8 @@
 	"exec",		/* 63 M_EXEC */ \
 	"miscfs mount",	/* 64 M_MISCFSMNT */ \
 	"fusefs mount", /* 65 M_FUSEFS */ \
-	NULL, \
-	NULL, \
+	"cwfs mount",	/* 66 M_CWFSMNT */ \
+	"cwfs node",	/* 67 M_CWFSNODE */ \
 	NULL, \
 	NULL, \
 	NULL, \
Index: sys/mount.h
===================================================================
RCS file: /cvs/src/sys/sys/mount.h,v
retrieving revision 1.148
diff -u -p -r1.148 mount.h
--- sys/mount.h	6 Apr 2021 14:17:35 -0000	1.148
+++ sys/mount.h	20 May 2021 21:34:23 -0000
@@ -240,6 +240,24 @@ struct tmpfs_args {
 };
 
 /*
+ * Arguments to mount cwfs file systems
+ */
+#define CWFS_ARGS_VERSION	1
+struct cwfs_args {
+	int	 cwa_version;
+
+	char	*cwa_fspec;		/* block special device to mount */
+	struct	export_args cwa_export_info;/* network export information */
+
+	/* Root node attributes. */
+	uid_t	 cwa_root_uid;
+	gid_t	 cwa_root_gid;
+	mode_t	 cwa_root_mode;
+
+	/* TODO */
+};
+
+/*
  * Arguments to mount fusefs filesystems
  */
 struct fusefs_args {
@@ -273,6 +291,7 @@ union mount_info {
 	struct msdosfs_args msdosfs_args;
 	struct ntfs_args ntfs_args;
 	struct tmpfs_args tmpfs_args;
+	struct cwfs_args cwfs_args;
 	char __align[160];	/* 64-bit alignment and room to grow */
 };
 
@@ -325,6 +344,7 @@ struct statfs {
 #define	MOUNT_UDF	"udf"		/* UDF */
 #define	MOUNT_TMPFS	"tmpfs"		/* tmpfs */
 #define	MOUNT_FUSEFS	"fuse"		/* FUSE */
+#define	MOUNT_CWFS	"cwfs"		/* course work file system */
 
 /*
  * Structure per mounted file system.  Each mounted file system has an
@@ -558,6 +578,7 @@ extern	const struct vfsops ntfs_vfsops;
 extern	const struct vfsops udf_vfsops;
 extern	const struct vfsops fusefs_vfsops;
 extern	const struct vfsops tmpfs_vfsops;
+extern	const struct vfsops cwfs_vfsops;
 
 #include <net/radix.h>
 #include <sys/socket.h>		/* XXX for AF_MAX */
Index: sys/vnode.h
===================================================================
RCS file: /cvs/src/sys/sys/vnode.h,v
retrieving revision 1.156
diff -u -p -r1.156 vnode.h
--- sys/vnode.h	8 Apr 2020 08:07:52 -0000	1.156
+++ sys/vnode.h	20 May 2021 21:34:23 -0000
@@ -67,12 +67,14 @@ enum vtagtype	{
 	VT_NON, VT_UFS, VT_NFS, VT_MFS, VT_MSDOSFS,
 	VT_PORTAL, VT_PROCFS, VT_AFS, VT_ISOFS, VT_ADOSFS,
 	VT_EXT2FS, VT_VFS, VT_NTFS, VT_UDF, VT_FUSEFS, VT_TMPFS,
+	VT_CWFS
 };
 
 #define	VTAG_NAMES \
     "NON", "UFS", "NFS", "MFS", "MSDOSFS",			\
     "unused", "unused", "unused", "ISOFS", "unused",		\
-    "EXT2FS", "VFS", "NTFS", "UDF", "FUSEFS", "TMPFS"
+    "EXT2FS", "VFS", "NTFS", "UDF", "FUSEFS", "TMPFS"		\
+    "CWFS"
 
 /*
  * Each underlying filesystem allocates its own private area and hangs
